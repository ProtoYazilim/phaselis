<article class="shortcode_text">
<div class="shortcode_title">
<a class="btn" href="#">Component</a>
<h1>Form</h1>
<p>The <code>form</code> component is a Phaselis React-Native component used for various UI functionalities. This documentation covers its usage, props, and implementation details.</p>
<h4 class="c_head load-order-2">index</h4>
<p><strong>File:</strong> <code>index.tsx</code></p>
<p>No props found.</p>
<pre><code class="language-typescript" data-lang="typescript">import { createContext } from &quot;react&quot;;

const FormContext = createContext&lt;{
  registerComponent: any;
  unRegisterComponent: (name: string) =&gt; void;
  formId: string;
  submit: () =&gt; void;
  reset: () =&gt; void;
  meta: any;
  handleComponentChange: (event: any, name: string, value: any) =&gt; void;
  handleComponentBlur: (event: any, name: string, value: any) =&gt; void;
  updateComponentProps: any;
}&gt;({
  registerComponent: null,
  unRegisterComponent: () =&gt; {},
  formId: &quot;&quot;,
  submit: () =&gt; {},
  reset: () =&gt; {},
  meta: null,
  handleComponentChange: () =&gt; {},
  handleComponentBlur: () =&gt; {},
  updateComponentProps: null,
});

export default FormContext;
</code></pre>
<hr />
<h4 class="c_head load-order-2">index</h4>
<p><strong>File:</strong> <code>index.tsx</code></p>
<p><strong>Props:</strong><ul><li>IInputComponent - isCheckable?: boolean</li><li>IInputComponent - isFileUpload?: boolean</li><li>IInputComponent - defaultValue?: any</li><li>IInputComponent - checked?: boolean</li><li>IInputComponent - valueKey?: string</li><li>IActionComponent - type: "submit" | "reset"</li></ul></p>
<pre><code class="language-typescript" data-lang="typescript">import React, {
  FC,
  useEffect,
  useId,
  useImperativeHandle,
  useRef,
  useState,
} from &quot;react&quot;;
import { ConsumerHOC } from &quot;@protonative/provider&quot;;
import { IFormPropTypes, IFormPropType } from &quot;@protocommon/types&quot;;
import { isValid } from &quot;./lib&quot;;
import FormContext from &quot;./context&quot;;
import FormReference from &quot;./reference&quot;;

interface IInputComponent extends IFormPropTypes {
  isCheckable?: boolean;
  isFileUpload?: boolean;
  defaultValue?: any;
  checked?: boolean;
  valueKey?: string;
}

export interface IActionComponent {
  type: &quot;submit&quot; | &quot;reset&quot;;
}

export const Form: FC&lt;IFormPropType&gt; = (
  {
    children,
    contextValue,
    id,
    onReset,
    onSubmit,
    onError,
    onChange,
    ...otherProps
  },
  ref,
) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    setValues,
    getValues,
    setComponentProps,
    getComponentProps,
    validate,
    validateAll,
    getErrorField,
    showError,
    hideError,
    hideErrors,
  }));

  const formId = useId();

  const [meta, setMeta] = useState&lt;any&gt;({});
  const metaRef = useRef&lt;Record&lt;string, any&gt;&gt;({});

  const registerComponent = (componentProps: IInputComponent) =&gt; {
    metaRef.current[componentProps.name || new Date().toString()] = {
      ...componentProps,
      isCheckable: !!componentProps?.isCheckable,
      isFileUpload: !!componentProps?.isFileUpload,
      valueKey: componentProps?.valueKey || &quot;value&quot;,
      isUsed: false,
      defaultValue: componentProps?.defaultValue,
      ...(componentProps?.isCheckable
        ? { checked: !!componentProps?.checked }
        : {}),
    };
    setMeta(metaRef.current);
    setErrors();
  };

  const unRegisterComponent = (name: string): void =&gt; {
    const tempRefrence = { ...metaRef.current };
    delete tempRefrence[name];
    metaRef.current = tempRefrence;
    setMeta(metaRef.current);
  };

  const updateComponentProps = (componentNewProps: IInputComponent) =&gt; {
    if (componentNewProps.name) {
      metaRef.current[componentNewProps.name || &quot;&quot;] = {
        ...metaRef.current[componentNewProps.name],
        ...componentNewProps,
      };
      setMeta(metaRef.current);
      setErrors();
    }
  };

  const setValues = (object: any, callback?: Function) =&gt; {
    metaRef.current = {
      ...metaRef.current,
      ...Object.keys(object).reduce((newMeta: any, name: string) =&gt; {
        newMeta[name] = {
          ...metaRef.current[name],
        };
        if (isValid(object[name])) {
          // newMeta = setErrorByName(newMeta, name)
          newMeta[name].value = object[name];
          newMeta[name].isCheckable
            ? (newMeta[name].checked = object[name])
            : null;
          newMeta[name].isChanged = false;
          newMeta[name].isUsed = false;
          newMeta[name].error = newMeta[name].error || null;
        }

        return newMeta;
      }, {}),
    };
    setMeta(metaRef.current);
    setErrors();
  };

  const resetValues = (callback?: Function) =&gt; {
    metaRef.current = Object.keys(metaRef.current).reduce(
      (newMeta: any, name: string) =&gt; {
        const props = metaRef.current[name];
        let resetValue =
          props.resetValue !== undefined
            ? props.resetValue
            : metaRef.current[name].defaultValue || null;

        if (metaRef.current[name].isCheckable &amp;&amp; !resetValue)
          resetValue = false;

        newMeta[name] = {
          ...metaRef.current[name],
        };
        newMeta[name].isChanged = false;
        newMeta[name].isUsed = false;
        newMeta[name].error = null;
        newMeta[name][metaRef.current[name]?.valueKey || &quot;value&quot;] = resetValue;
        return newMeta;
      },
      {},
    );
    setMeta(metaRef.current);
  };

  const getComponentProps = (name: string) =&gt; {
    return metaRef.current[name];
  };

  const setComponentProps = (props: any) =&gt; {
    metaRef.current[props.name] = {
      ...metaRef.current[props.name],
      ...props,
    };
    setMeta(metaRef.current);
  };

  const setErrorByName = (newMeta: any, name: string) =&gt; {
    const tempNewMeta = { ...newMeta };
    tempNewMeta[name] = {
      ...metaRef.current[name],
    };
    const props = metaRef.current[name];

    if (props?.validations) {
      for (const validation of props?.validations) {
        const error = validation(props?.value, props, metaRef.current);

        if (error) {
          newMeta[name].error = error;

          break;
        } else {
          delete newMeta[name].error;
        }
      }
    }

    return newMeta;
  };

  const handleComponentChange = (event: any, name: string, value: any) =&gt; {
    const isUsed = metaRef.current[name]?.isUsed;
    const newValue = value || event?.target?.value;
    metaRef.current[name] = {
      ...metaRef.current[name],
      isChanged: true,
      isUsed: isUsed,
      value: newValue,
    };
    setErrors();
    setMeta(metaRef.current);
    onChange &amp;&amp; onChange(event, metaRef.current);
  };

  const handleComponentBlur = (event: any, name: string, value: any) =&gt; {
    const isUsed = metaRef.current[name]?.isUsed;
    const newValue = value || event?.target?.value;
    metaRef.current[name] = {
      ...metaRef.current[name],
      isChanged: true,
      isUsed: isUsed,
      value: newValue,
    };
    onChange &amp;&amp; onChange(event, metaRef.current);
  };

  const setErrors = () =&gt; {
    metaRef.current = Object.keys(metaRef.current).reduce(
      (newMeta: any, name: string) =&gt; {
        const props = metaRef.current[name];
        const value = props.value;
        const validations = props.validations;

        newMeta[name] = {
          ...metaRef.current[name],
        };

        if (validations) {
          for (const validation of validations) {
            const error = validation(value, props, metaRef.current);
            if (error) {
              newMeta[name].error = error;
              break;
            } else {
              delete newMeta[name].error;
            }
          }
        }

        return newMeta;
      },
      {},
    );

    setMeta(metaRef.current);
  };

  const getValues = () =&gt; {
    return Object.keys(metaRef.current).reduce((values: any, name) =&gt; {
      values[name] = metaRef.current[name].isCheckable
        ? metaRef.current[name].checked
        : metaRef.current[name].value;
      return values;
    }, {});
  };

  const validate = (name: string) =&gt; {
    metaRef.current = {
      ...metaRef.current,
      [name]: {
        ...metaRef.current[name],
        isChanged: true,
        isUsed: true,
      },
    };

    setMeta(metaRef.current);
    var errors = Object.keys(metaRef.current).filter((cmpName) =&gt; {
      return cmpName === name &amp;&amp; metaRef.current[name].error;
    });

    return !(errors &amp;&amp; errors.length &gt; 0);
  };

  const validateAll = () =&gt; {
    metaRef.current = {
      ...metaRef.current,
      ...Object.keys(metaRef.current).reduce((newMeta: any, name) =&gt; {
        newMeta[name] = {
          ...metaRef.current[name],
          isChanged: true,
          isUsed: true,
        };
        return newMeta;
      }, {}),
    };

    setMeta(metaRef.current);

    var errors = Object.keys(metaRef.current).filter((name) =&gt; {
      return metaRef.current[name].error;
    });

    return !(errors &amp;&amp; errors.length &gt; 0);
  };

  const getErrorField = () =&gt; {
    var errors = Object.keys(metaRef.current).filter((name) =&gt; {
      return metaRef.current[name].error;
    });
    return errors &amp;&amp; errors.length &gt; 0 ? errors : [];
  };

  const showError = (name: string, error: any) =&gt; {
    if (name) {
      metaRef.current = {
        ...metaRef.current,
        [name]: {
          ...metaRef.current[name],
          isChanged: true,
          isUsed: true,
          error,
        },
      };
      setMeta(metaRef.current);
    }
  };

  const hideError = (name: string) =&gt; {
    metaRef.current = {
      ...metaRef.current,
      [name]: {
        ...metaRef.current[name],
        error: null,
        isChanged: false,
        isUsed: false,
      },
    };
    setMeta(metaRef.current);
  };

  const hideErrors = () =&gt; {
    metaRef.current = {
      ...metaRef.current,
      ...Object.keys(metaRef.current).reduce((newMeta: any, name) =&gt; {
        newMeta[name] = {
          ...metaRef.current[name],
          error: null,
          isChanged: false,
          isUsed: false,
        };
        return newMeta;
      }, {}),
    };
    setMeta(metaRef.current);
  };

  useEffect(() =&gt; {
    // console.log(`Form:${formId}-${id}`, meta)
  }, [meta]);

  const submit = () =&gt; {
    let validationResult = validateAll();
    let values = getValues();
    if (onSubmit) {
      if (validationResult) {
        onSubmit({ target: { value: null } }, values);
      }
    }

    if (onError) {
      if (!validationResult) {
        onError(&quot;event&quot;, getErrorField());
      }
    }
  };

  const reset = () =&gt; {
    resetValues();
    if (onReset) {
      onReset();
    }
  };

  return (
    &lt;FormContext.Provider
      value={{
        registerComponent: registerComponent,
        unRegisterComponent: unRegisterComponent,
        formId: formId,
        submit: submit,
        reset: reset,
        meta: meta,
        handleComponentChange: handleComponentChange,
        handleComponentBlur: handleComponentBlur,
        updateComponentProps: updateComponentProps,
      }}
    &gt;
      {children}
    &lt;/FormContext.Provider&gt;
  );
};

Form.displayName = &quot;form&quot;;
export type { FormReference };
export { FormContext };
export default ConsumerHOC&lt;IFormPropType&gt;(React.forwardRef(Form as any));
</code></pre>
<hr />
<h4 class="c_head load-order-2">info</h4>
<p><strong>File:</strong> <code>info.json</code></p>
<p>No props found.</p>
<pre><code class="language-typescript" data-lang="typescript">{
    &quot;name&quot;: &quot;@protonative/form&quot;,
    &quot;version&quot;: &quot;0.0.5&quot;,
    &quot;description&quot;: &quot;Proto Native Form Component&quot;,
    &quot;keywords&quot;: &quot;@protonative,proto,component,form&quot;
}</code></pre>
<hr />
<h4 class="c_head load-order-2">index</h4>
<p><strong>File:</strong> <code>index.tsx</code></p>
<p>No props found.</p>
<pre><code class="language-typescript" data-lang="typescript">const isValid = (value: any) =&gt; {
  return typeof value !== &quot;undefined&quot; &amp;&amp; value !== null;
};

export { isValid };
</code></pre>
<hr />
<h4 class="c_head load-order-2">package</h4>
<p><strong>File:</strong> <code>package.json</code></p>
<p>No props found.</p>
<pre><code class="language-typescript" data-lang="typescript">{
  &quot;name&quot;: &quot;@protonative/form&quot;
}
</code></pre>
<hr />
<h4 class="c_head load-order-2">index</h4>
<p><strong>File:</strong> <code>index.tsx</code></p>
<p><strong>Props:</strong><ul><li>FormReference - setValues: (object: any, callback?: Function) => void</li><li>FormReference - getValues: () => any</li><li>FormReference - setComponentProps: (props: any) => void</li><li>FormReference - getComponentProps: (name: string) => any</li><li>FormReference - validate: (name: string) => boolean</li><li>FormReference - validateAll: () => boolean</li><li>FormReference - getErrorField: () => string[]</li><li>FormReference - showError: (name: string, error: any) => void</li><li>FormReference - hideError: (name: string) => void</li><li>FormReference - hideErrors: () => void</li></ul></p>
<pre><code class="language-typescript" data-lang="typescript">interface FormReference {
  setValues: (object: any, callback?: Function) =&gt; void;
  getValues: () =&gt; any;
  setComponentProps: (props: any) =&gt; void;
  getComponentProps: (name: string) =&gt; any;
  validate: (name: string) =&gt; boolean;
  validateAll: () =&gt; boolean;
  getErrorField: () =&gt; string[];
  showError: (name: string, error: any) =&gt; void;
  hideError: (name: string) =&gt; void;
  hideErrors: () =&gt; void;
}

export default FormReference;
</code></pre>
<hr />
</div>
</article>
